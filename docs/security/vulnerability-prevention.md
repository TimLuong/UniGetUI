# Vulnerability Prevention and Security Best Practices

## Overview

This document provides comprehensive guidance on protecting Windows desktop applications against common vulnerabilities, with a focus on OWASP Top 10 and Windows-specific security considerations.

## Table of Contents

1. [OWASP Top 10 for Desktop Applications](#owasp-top-10-for-desktop-applications)
2. [Input Validation and Sanitization](#input-validation-and-sanitization)
3. [Secure Communication](#secure-communication)
4. [Command Injection Prevention](#command-injection-prevention)
5. [Path Traversal Prevention](#path-traversal-prevention)
6. [XML/JSON Security](#xmljson-security)
7. [Dependency Security](#dependency-security)
8. [Code Injection Prevention](#code-injection-prevention)
9. [Privilege Escalation Prevention](#privilege-escalation-prevention)
10. [Security Checklist](#security-checklist)

---

## OWASP Top 10 for Desktop Applications

### 1. Injection Attacks

#### Command Injection

**Vulnerability:**
```csharp
// ❌ DANGEROUS: Direct command execution
public void UninstallPackage(string packageName)
{
    var process = new Process();
    process.StartInfo.FileName = "cmd.exe";
    process.StartInfo.Arguments = $"/c winget uninstall {packageName}";
    process.Start();
}
// Attacker input: "notepad & del /f /q C:\*.*"
```

**Secure Implementation:**
```csharp
// ✅ SAFE: Use ArgumentList with validation
public void UninstallPackage(string packageName)
{
    // Validate input
    if (!IsValidPackageName(packageName))
        throw new ArgumentException("Invalid package name", nameof(packageName));
    
    var process = new Process();
    process.StartInfo = new ProcessStartInfo
    {
        FileName = "winget",
        UseShellExecute = false,
        CreateNoWindow = true
    };
    
    // Use ArgumentList to prevent injection
    process.StartInfo.ArgumentList.Add("uninstall");
    process.StartInfo.ArgumentList.Add(packageName);
    
    process.Start();
}

private bool IsValidPackageName(string name)
{
    // Only allow alphanumeric, dots, hyphens, and underscores
    return Regex.IsMatch(name, @"^[a-zA-Z0-9.\-_]+$") && 
           name.Length <= 100;
}
```

#### SQL Injection (for apps using databases)

**Vulnerability:**
```csharp
// ❌ DANGEROUS: String concatenation
public User GetUser(string username)
{
    var query = $"SELECT * FROM Users WHERE Username = '{username}'";
    return ExecuteQuery(query);
}
// Attacker input: "admin' OR '1'='1"
```

**Secure Implementation:**
```csharp
// ✅ SAFE: Parameterized queries
public User? GetUser(string username)
{
    const string query = "SELECT * FROM Users WHERE Username = @Username";
    
    using var connection = new SqlConnection(connectionString);
    using var command = new SqlCommand(query, connection);
    
    command.Parameters.AddWithValue("@Username", username);
    
    connection.Open();
    using var reader = command.ExecuteReader();
    
    if (reader.Read())
    {
        return new User
        {
            Username = reader.GetString(0),
            Email = reader.GetString(1)
        };
    }
    
    return null;
}
```

### 2. Broken Authentication

**Secure Token Generation:**
```csharp
using System.Security.Cryptography;

public class SecureTokenGenerator
{
    // ❌ WEAK: Using Random
    public static string WeakToken()
    {
        var random = new Random();
        return random.Next().ToString();
    }
    
    // ✅ STRONG: Using RandomNumberGenerator
    public static string GenerateToken(int length = 32)
    {
        var bytes = new byte[length];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(bytes);
        }
        return Convert.ToBase64String(bytes);
    }
    
    // ✅ STRONG: Cryptographic random string
    public static string GenerateSecureString(int length = 32)
    {
        const string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        var bytes = new byte[length];
        
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(bytes);
        }
        
        var result = new char[length];
        for (int i = 0; i < length; i++)
        {
            result[i] = chars[bytes[i] % chars.Length];
        }
        
        return new string(result);
    }
}
```

**Token Validation:**
```csharp
public class TokenValidator
{
    private readonly string _expectedToken;
    private readonly TimeSpan _tokenLifetime;
    private readonly DateTime _tokenCreated;
    
    public TokenValidator(string token, TimeSpan lifetime)
    {
        _expectedToken = token ?? throw new ArgumentNullException(nameof(token));
        _tokenLifetime = lifetime;
        _tokenCreated = DateTime.UtcNow;
    }
    
    public bool ValidateToken(string? providedToken)
    {
        // Check for null or empty
        if (string.IsNullOrEmpty(providedToken))
            return false;
        
        // Check expiration
        if (DateTime.UtcNow - _tokenCreated > _tokenLifetime)
            return false;
        
        // Constant-time comparison to prevent timing attacks
        return CryptographicOperations.FixedTimeEquals(
            Encoding.UTF8.GetBytes(_expectedToken),
            Encoding.UTF8.GetBytes(providedToken)
        );
    }
}
```

### 3. Sensitive Data Exposure

**Secure Logging:**
```csharp
public class SecureLogger
{
    private static readonly HashSet<string> SensitiveKeys = new(StringComparer.OrdinalIgnoreCase)
    {
        "password", "token", "apikey", "secret", "credential", 
        "connectionstring", "privatekey", "certificate"
    };
    
    // ❌ DANGEROUS: Logging everything
    public static void UnsafeLog(object data)
    {
        Logger.Info(JsonSerializer.Serialize(data));
        // Might expose passwords, tokens, etc.
    }
    
    // ✅ SAFE: Redacting sensitive data
    public static void SafeLog(string message, Dictionary<string, object>? data = null)
    {
        if (data != null)
        {
            var sanitized = new Dictionary<string, object>();
            
            foreach (var kvp in data)
            {
                if (IsSensitiveKey(kvp.Key))
                {
                    sanitized[kvp.Key] = "***REDACTED***";
                }
                else
                {
                    sanitized[kvp.Key] = kvp.Value;
                }
            }
            
            Logger.Info($"{message}: {JsonSerializer.Serialize(sanitized)}");
        }
        else
        {
            Logger.Info(message);
        }
    }
    
    private static bool IsSensitiveKey(string key)
    {
        return SensitiveKeys.Any(sensitive => 
            key.Contains(sensitive, StringComparison.OrdinalIgnoreCase)
        );
    }
}

// Usage
SecureLogger.SafeLog("User login attempt", new Dictionary<string, object>
{
    ["Username"] = "john.doe",
    ["Password"] = "secret123", // Will be redacted
    ["IpAddress"] = "192.168.1.1"
});
```

**Memory Protection:**
```csharp
public class SecretHandler : IDisposable
{
    private byte[]? _secretData;
    private bool _disposed;
    
    public SecretHandler(string secret)
    {
        _secretData = Encoding.UTF8.GetBytes(secret);
    }
    
    public string GetSecret()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(SecretHandler));
        
        if (_secretData == null)
            throw new InvalidOperationException("Secret data is null");
        
        return Encoding.UTF8.GetString(_secretData);
    }
    
    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (_secretData != null)
        {
            // Overwrite memory before releasing
            Array.Clear(_secretData, 0, _secretData.Length);
            _secretData = null;
        }
        
        _disposed = true;
        GC.SuppressFinalize(this);
    }
    
    ~SecretHandler()
    {
        Dispose();
    }
}

// Usage
using (var handler = new SecretHandler("my-secret-key"))
{
    var secret = handler.GetSecret();
    // Use secret
    // Secret automatically cleared from memory when disposed
}
```

### 4. XML External Entities (XXE)

**Vulnerable XML Parsing:**
```csharp
// ❌ DANGEROUS: Default XML settings
public void ParseXml(string xmlContent)
{
    var doc = new XmlDocument();
    doc.LoadXml(xmlContent); // Vulnerable to XXE attacks
}
```

**Secure XML Parsing:**
```csharp
// ✅ SAFE: Secure XML settings
public void ParseXmlSecure(string xmlContent)
{
    var settings = new XmlReaderSettings
    {
        DtdProcessing = DtdProcessing.Prohibit,
        XmlResolver = null,
        MaxCharactersFromEntities = 1024,
        MaxCharactersInDocument = 1024 * 1024 // 1MB limit
    };
    
    using var stringReader = new StringReader(xmlContent);
    using var xmlReader = XmlReader.Create(stringReader, settings);
    
    var doc = new XmlDocument();
    doc.Load(xmlReader);
    
    // Process document
}

// ✅ SAFE: Using XDocument
public void ParseXmlWithXDocument(string xmlContent)
{
    var settings = new XmlReaderSettings
    {
        DtdProcessing = DtdProcessing.Prohibit,
        XmlResolver = null
    };
    
    using var stringReader = new StringReader(xmlContent);
    using var xmlReader = XmlReader.Create(stringReader, settings);
    
    var doc = XDocument.Load(xmlReader);
    
    // Process document
}
```

### 5. Broken Access Control

**Secure Settings Management:**

UniGetUI implements secure settings with elevation:

```csharp
public static class SecureSettings
{
    // Settings stored in Program Files (admin access required)
    private const string SecureSettingsPath = @"C:\Program Files\UniGetUI\SecureSettings";
    
    public static bool Get(K key)
    {
        string purifiedSetting = CoreTools.MakeValidFileName(ResolveKey(key));
        string purifiedUser = CoreTools.MakeValidFileName(Environment.UserName);
        
        var settingsLocation = Path.Join(SecureSettingsPath, purifiedUser);
        var settingFile = Path.Join(settingsLocation, purifiedSetting);
        
        // Read-only access for regular users
        return File.Exists(settingFile);
    }
    
    public static async Task<bool> TrySet(K key, bool enabled)
    {
        // Require elevation to modify secure settings
        using Process p = new Process();
        p.StartInfo = new()
        {
            UseShellExecute = true,
            FileName = CoreData.UniGetUIExecutableFile,
            Verb = "runas", // Request admin elevation
            ArgumentList = { /* parameters */ }
        };
        
        p.Start();
        await p.WaitForExitAsync();
        return p.ExitCode is 0;
    }
}
```

**File Access Validation:**
```csharp
public class SecureFileAccess
{
    private readonly string _allowedDirectory;
    
    public SecureFileAccess(string allowedDirectory)
    {
        _allowedDirectory = Path.GetFullPath(allowedDirectory);
    }
    
    public string ReadFile(string fileName)
    {
        // Validate and resolve path
        var fullPath = GetValidatedPath(fileName);
        
        // Check if file exists
        if (!File.Exists(fullPath))
            throw new FileNotFoundException("File not found", fileName);
        
        return File.ReadAllText(fullPath);
    }
    
    private string GetValidatedPath(string fileName)
    {
        // Remove path separators from filename
        var sanitizedName = Path.GetFileName(fileName);
        
        // Construct full path
        var fullPath = Path.GetFullPath(Path.Combine(_allowedDirectory, sanitizedName));
        
        // Ensure path is within allowed directory
        if (!fullPath.StartsWith(_allowedDirectory, StringComparison.OrdinalIgnoreCase))
        {
            throw new UnauthorizedAccessException(
                $"Access denied: Path '{fileName}' is outside allowed directory"
            );
        }
        
        return fullPath;
    }
}
```

### 6. Security Misconfiguration

**Secure Process Execution:**
```csharp
public class SecureProcessExecutor
{
    // ❌ DANGEROUS: Using shell execution
    public void ExecuteUnsafe(string command)
    {
        var process = new Process();
        process.StartInfo.FileName = "cmd.exe";
        process.StartInfo.Arguments = $"/c {command}";
        process.StartInfo.UseShellExecute = true; // Vulnerable
        process.Start();
    }
    
    // ✅ SAFE: Direct execution without shell
    public async Task<ProcessResult> ExecuteSecure(
        string executable, 
        IEnumerable<string> arguments
    )
    {
        // Validate executable path
        if (!File.Exists(executable))
            throw new FileNotFoundException("Executable not found", executable);
        
        var process = new Process();
        process.StartInfo = new ProcessStartInfo
        {
            FileName = executable,
            UseShellExecute = false,
            CreateNoWindow = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            RedirectStandardInput = false
        };
        
        // Add arguments individually (prevents injection)
        foreach (var arg in arguments)
        {
            process.StartInfo.ArgumentList.Add(arg);
        }
        
        process.Start();
        
        var output = await process.StandardOutput.ReadToEndAsync();
        var error = await process.StandardError.ReadToEndAsync();
        
        await process.WaitForExitAsync();
        
        return new ProcessResult
        {
            ExitCode = process.ExitCode,
            StandardOutput = output,
            StandardError = error
        };
    }
}

public class ProcessResult
{
    public int ExitCode { get; set; }
    public string StandardOutput { get; set; } = "";
    public string StandardError { get; set; } = "";
}
```

### 7. Cross-Site Scripting (XSS) - WebView Controls

**Vulnerable WebView:**
```csharp
// ❌ DANGEROUS: Injecting user input directly
public void DisplayUserContent(string userInput)
{
    var html = $"<html><body><h1>{userInput}</h1></body></html>";
    webView.NavigateToString(html);
}
// Attacker input: "<script>alert('XSS')</script>"
```

**Secure WebView:**
```csharp
// ✅ SAFE: HTML encoding
using System.Net;

public void DisplayUserContentSafe(string userInput)
{
    var encodedInput = WebUtility.HtmlEncode(userInput);
    var html = $"<html><body><h1>{encodedInput}</h1></body></html>";
    webView.NavigateToString(html);
}

// ✅ SAFE: Content Security Policy
public void DisplayWithCSP(string safeHtml)
{
    var html = $@"
        <!DOCTYPE html>
        <html>
        <head>
            <meta http-equiv='Content-Security-Policy' 
                  content=""default-src 'self'; script-src 'none'; style-src 'self' 'unsafe-inline';"">
        </head>
        <body>
            {WebUtility.HtmlEncode(safeHtml)}
        </body>
        </html>";
    
    webView.NavigateToString(html);
}
```

### 8. Insecure Deserialization

**Vulnerable Deserialization:**
```csharp
// ❌ DANGEROUS: BinaryFormatter (deprecated and insecure)
public object DeserializeUnsafe(byte[] data)
{
    var formatter = new BinaryFormatter();
    using var stream = new MemoryStream(data);
    return formatter.Deserialize(stream); // Vulnerable to code execution
}
```

**Secure Deserialization:**
```csharp
// ✅ SAFE: JSON with validation
using System.Text.Json;

public class SecureDeserializer
{
    private static readonly JsonSerializerOptions Options = new()
    {
        PropertyNameCaseInsensitive = true,
        MaxDepth = 32,
        AllowTrailingCommas = false
    };
    
    public static T? Deserialize<T>(string json) where T : class
    {
        try
        {
            var result = JsonSerializer.Deserialize<T>(json, Options);
            
            // Validate deserialized object
            if (result is IValidatable validatable)
            {
                if (!validatable.Validate())
                    throw new InvalidDataException("Validation failed");
            }
            
            return result;
        }
        catch (JsonException ex)
        {
            Logger.Error($"Deserialization failed: {ex.Message}");
            throw;
        }
    }
}

// Validatable object
public interface IValidatable
{
    bool Validate();
}

public class UserSettings : IValidatable
{
    public string Username { get; set; } = "";
    public int MaxConnections { get; set; }
    
    public bool Validate()
    {
        return !string.IsNullOrWhiteSpace(Username) &&
               Username.Length <= 100 &&
               MaxConnections > 0 &&
               MaxConnections <= 1000;
    }
}
```

### 9. Using Components with Known Vulnerabilities

**Dependency Scanning:**

```xml
<!-- Add to .csproj -->
<PropertyGroup>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <AnalysisLevel>latest</AnalysisLevel>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
</PropertyGroup>
```

**Automated Vulnerability Scanning:**

Use GitHub Dependabot or similar tools:

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "nuget"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
```

### 10. Insufficient Logging & Monitoring

**Comprehensive Logging:**
```csharp
public class SecurityLogger
{
    private static readonly ILogger Logger = LogManager.GetCurrentClassLogger();
    
    public static void LogAuthenticationAttempt(
        string username, 
        bool success, 
        string ipAddress
    )
    {
        var logData = new
        {
            EventType = "Authentication",
            Username = username,
            Success = success,
            IpAddress = ipAddress,
            Timestamp = DateTime.UtcNow
        };
        
        if (success)
        {
            Logger.Info($"Successful authentication: {JsonSerializer.Serialize(logData)}");
        }
        else
        {
            Logger.Warn($"Failed authentication: {JsonSerializer.Serialize(logData)}");
        }
    }
    
    public static void LogSecurityEvent(
        string eventType, 
        string description, 
        Dictionary<string, object> context
    )
    {
        var logData = new
        {
            EventType = eventType,
            Description = description,
            Context = context,
            Timestamp = DateTime.UtcNow,
            User = Environment.UserName,
            Machine = Environment.MachineName
        };
        
        Logger.Warn($"Security event: {JsonSerializer.Serialize(logData)}");
    }
    
    public static void LogAccessViolation(string resource, string attemptedAction)
    {
        LogSecurityEvent("AccessViolation", $"Unauthorized access attempt to {resource}", 
            new Dictionary<string, object>
            {
                ["Resource"] = resource,
                ["Action"] = attemptedAction,
                ["StackTrace"] = Environment.StackTrace
            }
        );
    }
}
```

---

## Input Validation and Sanitization

### Validation Patterns

```csharp
public static class InputValidator
{
    // Validate package names
    public static bool IsValidPackageName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return false;
        
        // Allow alphanumeric, dots, hyphens, underscores
        return Regex.IsMatch(name, @"^[a-zA-Z0-9.\-_]+$") && 
               name.Length >= 1 && 
               name.Length <= 100;
    }
    
    // Validate file names
    public static bool IsValidFileName(string fileName)
    {
        if (string.IsNullOrWhiteSpace(fileName))
            return false;
        
        // Check for invalid characters
        var invalidChars = Path.GetInvalidFileNameChars();
        if (fileName.IndexOfAny(invalidChars) >= 0)
            return false;
        
        // Check length
        return fileName.Length <= 255;
    }
    
    // Validate URLs
    public static bool IsValidUrl(string url, bool httpsOnly = true)
    {
        if (string.IsNullOrWhiteSpace(url))
            return false;
        
        if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))
            return false;
        
        if (httpsOnly && uri.Scheme != Uri.UriSchemeHttps)
            return false;
        
        return uri.Scheme == Uri.UriSchemeHttp || 
               uri.Scheme == Uri.UriSchemeHttps;
    }
    
    // Validate email addresses
    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;
        
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }
    
    // Sanitize file names
    public static string SanitizeFileName(string fileName)
    {
        var invalidChars = Path.GetInvalidFileNameChars();
        var sanitized = string.Join("_", fileName.Split(invalidChars));
        
        // Limit length
        if (sanitized.Length > 255)
            sanitized = sanitized.Substring(0, 255);
        
        return sanitized;
    }
    
    // Sanitize for display (prevent XSS in logs/UI)
    public static string SanitizeForDisplay(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;
        
        return System.Net.WebUtility.HtmlEncode(input);
    }
}
```

### Comprehensive Input Validation

```csharp
public class ValidationResult
{
    public bool IsValid { get; set; }
    public List<string> Errors { get; set; } = new();
    
    public void AddError(string error)
    {
        IsValid = false;
        Errors.Add(error);
    }
}

public class PackageValidator
{
    public ValidationResult ValidatePackageInstallRequest(
        string packageName,
        string? version,
        string? source
    )
    {
        var result = new ValidationResult { IsValid = true };
        
        // Validate package name
        if (string.IsNullOrWhiteSpace(packageName))
        {
            result.AddError("Package name is required");
        }
        else if (!InputValidator.IsValidPackageName(packageName))
        {
            result.AddError("Package name contains invalid characters");
        }
        
        // Validate version if provided
        if (version != null && !IsValidVersion(version))
        {
            result.AddError($"Invalid version format: {version}");
        }
        
        // Validate source if provided
        if (source != null && !IsValidSource(source))
        {
            result.AddError($"Invalid source: {source}");
        }
        
        return result;
    }
    
    private bool IsValidVersion(string version)
    {
        return Regex.IsMatch(version, @"^\d+(\.\d+){0,3}$");
    }
    
    private bool IsValidSource(string source)
    {
        var validSources = new[] { "winget", "scoop", "chocolatey", "pip", "npm" };
        return validSources.Contains(source, StringComparer.OrdinalIgnoreCase);
    }
}
```

---

## Secure Communication

### TLS/HTTPS Enforcement

```csharp
public class SecureHttpClient
{
    private readonly HttpClient _client;
    
    public SecureHttpClient()
    {
        var handler = new HttpClientHandler
        {
            // Enforce TLS 1.2 or higher
            SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13,
            
            // Enable certificate validation
            ServerCertificateCustomValidationCallback = ValidateCertificate
        };
        
        _client = new HttpClient(handler)
        {
            Timeout = TimeSpan.FromSeconds(30)
        };
        
        // Set secure headers
        _client.DefaultRequestHeaders.Add("User-Agent", "MyApp/1.0");
    }
    
    private bool ValidateCertificate(
        HttpRequestMessage request,
        X509Certificate2? certificate,
        X509Chain? chain,
        SslPolicyErrors sslPolicyErrors
    )
    {
        // In production, always validate certificates
        if (sslPolicyErrors == SslPolicyErrors.None)
            return true;
        
        Logger.Error($"Certificate validation failed: {sslPolicyErrors}");
        return false;
    }
    
    public async Task<string> GetAsync(string url)
    {
        // Validate URL
        if (!InputValidator.IsValidUrl(url, httpsOnly: true))
            throw new ArgumentException("Invalid or non-HTTPS URL", nameof(url));
        
        var response = await _client.GetAsync(url);
        response.EnsureSuccessStatusCode();
        
        return await response.Content.ReadAsStringAsync();
    }
}
```

### Certificate Pinning

```csharp
public class CertificatePinningHandler : HttpClientHandler
{
    private readonly HashSet<string> _pinnedCertificates;
    
    public CertificatePinningHandler(params string[] certificateHashes)
    {
        _pinnedCertificates = new HashSet<string>(certificateHashes);
        ServerCertificateCustomValidationCallback = ValidatePinnedCertificate;
    }
    
    private bool ValidatePinnedCertificate(
        HttpRequestMessage request,
        X509Certificate2? certificate,
        X509Chain? chain,
        SslPolicyErrors sslPolicyErrors
    )
    {
        if (certificate == null)
            return false;
        
        // Compute certificate hash
        using var sha256 = SHA256.Create();
        var certHash = sha256.ComputeHash(certificate.RawData);
        var certHashString = Convert.ToBase64String(certHash);
        
        // Check if certificate is pinned
        if (_pinnedCertificates.Contains(certHashString))
        {
            Logger.Debug("Certificate pinning validation successful");
            return true;
        }
        
        Logger.Error($"Certificate pinning validation failed. Hash: {certHashString}");
        return false;
    }
}

// Usage
var pinnedHashes = new[]
{
    "base64-encoded-cert-hash-1",
    "base64-encoded-cert-hash-2"
};

var handler = new CertificatePinningHandler(pinnedHashes);
var client = new HttpClient(handler);
```

---

## Command Injection Prevention

UniGetUI properly handles package manager execution:

```csharp
public class SafeProcessExecutor
{
    // ✅ SAFE: Uses ArgumentList to prevent injection
    public async Task<string> ExecutePackageManager(
        string manager,
        string command,
        params string[] arguments
    )
    {
        // Validate manager path
        if (!IsValidManagerPath(manager))
            throw new ArgumentException("Invalid manager path", nameof(manager));
        
        var process = new Process();
        process.StartInfo = new ProcessStartInfo
        {
            FileName = manager,
            UseShellExecute = false, // Critical: Don't use shell
            CreateNoWindow = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true
        };
        
        // Add command and arguments individually
        process.StartInfo.ArgumentList.Add(command);
        foreach (var arg in arguments)
        {
            // Validate each argument
            if (string.IsNullOrWhiteSpace(arg))
                continue;
            
            process.StartInfo.ArgumentList.Add(arg);
        }
        
        process.Start();
        
        var output = await process.StandardOutput.ReadToEndAsync();
        await process.WaitForExitAsync();
        
        return output;
    }
    
    private bool IsValidManagerPath(string path)
    {
        if (!File.Exists(path))
            return false;
        
        // Ensure it's in a trusted directory
        var trustedPaths = new[]
        {
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
            Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Microsoft")
        };
        
        var fullPath = Path.GetFullPath(path);
        return trustedPaths.Any(trusted => 
            fullPath.StartsWith(trusted, StringComparison.OrdinalIgnoreCase)
        );
    }
}
```

---

## Path Traversal Prevention

```csharp
public class SecurePathHandler
{
    private readonly string _baseDirectory;
    
    public SecurePathHandler(string baseDirectory)
    {
        _baseDirectory = Path.GetFullPath(baseDirectory);
        
        if (!Directory.Exists(_baseDirectory))
            Directory.CreateDirectory(_baseDirectory);
    }
    
    public string GetSecurePath(string relativePath)
    {
        // Remove any directory traversal attempts
        var sanitized = relativePath.Replace("..", "");
        
        // Get filename only
        var fileName = Path.GetFileName(sanitized);
        
        // Construct full path
        var fullPath = Path.GetFullPath(Path.Combine(_baseDirectory, fileName));
        
        // Verify path is within base directory
        if (!fullPath.StartsWith(_baseDirectory, StringComparison.OrdinalIgnoreCase))
        {
            throw new UnauthorizedAccessException(
                $"Path traversal attempt detected: {relativePath}"
            );
        }
        
        return fullPath;
    }
    
    public string ReadSecureFile(string relativePath)
    {
        var securePath = GetSecurePath(relativePath);
        
        if (!File.Exists(securePath))
            throw new FileNotFoundException("File not found", relativePath);
        
        return File.ReadAllText(securePath);
    }
    
    public void WriteSecureFile(string relativePath, string content)
    {
        var securePath = GetSecurePath(relativePath);
        File.WriteAllText(securePath, content);
    }
}

// Usage
var handler = new SecurePathHandler(
    Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        "MyApp",
        "Data"
    )
);

// ✅ SAFE: These will work
handler.WriteSecureFile("config.json", jsonData);
handler.ReadSecureFile("settings.txt");

// ❌ BLOCKED: These will throw UnauthorizedAccessException
// handler.ReadSecureFile("../../Windows/System32/config/SAM");
// handler.ReadSecureFile("..\\..\\..\\sensitive-file.txt");
```

---

## Security Checklist

### Development Phase

- [ ] Input validation on all user inputs
- [ ] Output encoding for all display data
- [ ] Parameterized queries for database access
- [ ] Use ArgumentList for process execution
- [ ] Proper error handling without information disclosure
- [ ] Secure credential storage (Windows Credential Manager/DPAPI)
- [ ] TLS/HTTPS for all network communication
- [ ] Certificate validation enabled
- [ ] Secure random number generation
- [ ] Path traversal prevention
- [ ] XML/JSON secure parsing
- [ ] Proper logging without sensitive data
- [ ] Memory cleanup for sensitive data

### Build Phase

- [ ] Enable code analysis (CA rules)
- [ ] Run security linters
- [ ] Dependency vulnerability scanning
- [ ] Sign code with valid certificate
- [ ] Remove debug symbols from release builds
- [ ] Obfuscate sensitive strings if needed

### Deployment Phase

- [ ] Secure update mechanism
- [ ] Verify package signatures
- [ ] Least privilege installation
- [ ] Secure default configuration
- [ ] Clear installation audit trail

### Runtime Phase

- [ ] Regular security updates
- [ ] Monitor security logs
- [ ] Incident response plan ready
- [ ] User security awareness

---

## Related Documentation

- [Authentication Patterns](./authentication-patterns.md) - Secure authentication
- [Data Protection](./data-protection.md) - Encryption and storage
- [Security Testing](./security-testing.md) - Testing methodologies

---

## References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Desktop App Security](https://owasp.org/www-community/vulnerabilities/)
- [CWE/SANS Top 25](https://cwe.mitre.org/top25/)
- [Microsoft Security Development Lifecycle](https://www.microsoft.com/en-us/securityengineering/sdl)
- [.NET Security Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/security/)
